# Module 8 - Address Hacks, Advanced NFT

## Address Hacks

Address Hacks
- Create a simple set of smart contracts that shows how extcodesize can be bypassed in the constructor. Demonstrate that msg.sender == tx.origin will block calls from the constructor. Demonstrate this using OpenZeppelin’s [address library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol) ([documentation](https://docs.openzeppelin.com/contracts/4.x/api/utils#Address))
- Challenge #3 from Damn Vulnerable Defi: https://www.damnvulnerabledefi.xyz/challenges/3.html Hint: you need to understand the address library
- Ethernaut 14

### Damn Vulnerable DeFi Challenge #3 - Truster
More and more lending pools are offering flash loans. In this case, a new pool has launched that is offering flash loans of DVT tokens for free.
The pool holds 1 million DVT tokens. You have nothing.
To pass this challenge, take all tokens out of the pool. If possible, in a single transaction.

### Advanced NFT
- Implement a merkle tree airdrop where addresses in the merkle tree are allowed to mint once. Measure the gas cost of using a mapping to track if an address already minted vs tracking each address with a bit in a bitmap. Hint: the merkle leaf should be the hash of the address and its index in the bitmap. Use the bitmaps from OpenZeppelin
- Use commit reveal to allocate NFT ids randomly. The reveal should be 10 blocks ahead of the commit. You can look at cool cats NFT to see how this is done. They use chainlink, but you should use commit-reveal.
- Add multicall to the NFT so people can transfer several NFTs in one transaction (make sure people can’t abuse minting!)
- The NFT should use a state machine to determine if it is mints can happen, the presale is active, or the public sale is active, or the supply has run out. Require statements should only depend on the state (except when checking input validity)
- Designated address should be able to withdraw funds using the pull pattern. You should be able to withdraw to an arbitrary number of contributors

<i>Note: This project's primary concern is about the implementation of the smart contract and the above points, as such minimal effort is put into the frontend.</i>

### Ethernaut 14
- This gatekeeper introduces a few new challenges. Register as an entrant to pass this level.

Solution:
- GateOne: calling from a smart contract such as an attack contract rather from an EOA will bypass the first gate.
- GateTwo: on contract creation, extcodesize is 0, so executing the attack in the constructor will bypass this.
- GateThree: the gatekey can be easily derived by doing a reverse XOR with type(uint64).max

How to Run

1. cd into root directory
2. npm install
3. run 'npx hardhat node'
4. add the first account generated by hardhat or copy any localhost address and replace the hardcoded addresses in 'advanced-nft.js'
5. run 'npm run merkle' in another terminal window to generate the merkle file for the client
6. copy the deployed contract address into index.js
7. cd into the client directory
8. npm install
9. run 'npm run dev'
